#!/bin/bash

## Copyright 2018 Jack Green (ja-green)
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

## promptly
## easy to use, component based library for customising your bash prompt
##
## examples:
## edit your prompt:
##     $ prommptly edit -e vim
##
## show what your current prompt would look like:
##     $ promptly show
##
## list available components:
##     $ promptly help components
##
## get help with a specific component:
##     $ promptly help git_status
##

## variable definitions

prog_name="$(basename ${0})"
prog_repo="$(locate promptly/.git | head -n 1)/.."
prog_vers="0.1.0" #"$(cat ${prog_repo}/VERSION)"
prog_home="$(pwd)" #"$HOME/.promptly/"
prog_opts=":ahtb:p:"
prog_exit=0

source "${prog_home}/component.d/git"
source "${prog_home}/component.d/system"

components=("promptchar" "jobcount" "username" "uptime" "longdate" "shortdate_us" "shortdate_uk" \
"time24" "time" "exitstatus" "exitstatus_char" "pwd" "shortpwd")
m_cmds=("edit" "help" "show" "version")
s_cmds=("components" "${m_cmds[@]}" "${components[@]}")

# main usage text
main="${prog_name} v${prog_vers}\n\nmanage your bash prompt through promptly"

# command usage text
edit=("edit your bash prompt" "flags: \
  \n\t-e, --editor    specify an editor to use\n")
help=("get help with a command or concept" "")
show=("show your prompt as it would be rendered" "")
version=("show version information" "")

# status tags
stat_warn="warn:"
stat_fatal="fatal:"
stat_hint="hint:"

# error messages
err_no_argument="${stat_fatal} option '%s' requires an argument\n"
err_invalid_opt="${stat_fatal} unknown option '%s'\n"
err_invalid_m_cmd="${stat_fatal} '%s' is not a known command\n
run '${prog_name} --help' for a list of known commands\n"
err_invalid_s_cmd="${stat_fatal} '%s' is not a known subcommand\n"
err_no_man="${stat_fatal} no help text for '%s'\n"
err_no_editor="${stat_fatal} unrecognised editor\n"

usage_end="for help with each command run: \
  \n\t${prog_name} <command> -h | --help\n"

flags_global="global flags: \
  \n\t-h, --help      show this screen \
  \n\t-v, --version   show version information\n"

## usage functions

main_usage() {
  echo -e "${main}\n \
    \nusage:\
    \n\t${prog_name} [options] \
    \n\t${prog_name} <command> [options] \
    \n\ncommands:                   \
    \n\tedit            ${edit}     \
    \n\thelp            ${help}     \
    \n\tlist            ${list}     \
    \n\tshow            ${show}     \
    \n\tversion         ${version}  \n"

  echo -e "${flags_global}"
  echo -e "${usage_end}"

  exit ${prog_exit}
}

m_cmd_usage() {
  eval m_cmd_arr="(\"\${${m_cmd}[@]}\")"

  about="${m_cmd_arr[0]}"
  flags="${m_cmd_arr[1]}"

  echo -e "${about}\n \
    \nusage: \
    \n\t${prog_name} ${m_cmd} [options] \
    \n\t${prog_name} ${m_cmd} [microservice] [options]\n"

  echo -e "${flags}"
  echo -e "${flags_global}"
  echo -e "${usage_end}"

  exit ${prog_exit}
}

print_version() {
  echo -e "${prog_name} version ${prog_vers}"

  exit ${prog_exit}
}

## helper functions

is_m_cmd() {
  if [[ -z $(printf '%s\n' "${m_cmds[@]}" | grep -w ${1//-}) ]]; then
    return 1
  fi
}

is_m_cmd_set() {
  if [[ ! ${m_cmd+x} ]]; then
    return 1
  fi
}

set_m_cmd() {
  if ! is_m_cmd_set; then
    echo -e "${1}"
  fi
}

is_s_cmd() {
  if [[ -z $(printf '%s\n' "${s_cmds[@]}" | grep -w ${1//-}) ]]; then
    return 1
  fi
}

is_s_cmd_set() {
  if [[ ! ${s_cmd+x} ]]; then
    return 1
  fi
}

set_s_cmd() {
  if ! is_s_cmd_set; then
    echo -e "${1}"
  fi
}

is_component() {
  if [[ -z $(printf '%s\n' "${components[@]}" | grep -w ${1//-}) ]]; then
    return 1
  fi
}

die() {
  printf "${1}" "${2}" >&2

  if is_m_cmd "${2}" \
  && [[ ${m_cmd} != "help" ]]; then
    m_cmd_usage
  fi

  prog_exit=1
  exit ${prog_exit}
}

## prompt parsing functions

parse_any() {
  echo "${line:$i:1}"

  return 0
}

parse_esc() {
  echo $((i++)) &>/dev/null
  echo "${line:$i:1}"

  return 0
}

parse_cmd() {
  cmd=${line:$((i+1))}
  cmd=${cmd%%\)*}
  echo -e "$(eval cpnt_${cmd} 2>/dev/null)"

  return $((${#cmd}+1))
}

evaluate() {
  demo_ps1=""

  while read -r line; do
    [[ "${line}" == \#* ]] && continue

    for (( i=0; i<${#line}; i++ )); do

      case "${line:$i:1}" in
      \() demo_ps1+="$(parse_cmd)" ;;
      \\) demo_ps1+="$(parse_esc)" ;;
       *) demo_ps1+="$(parse_any)" ;;
      esac

      echo $((i+=${?})) &>/dev/null

    done
  done < "${prog_home}/PROMPT_STR"

  echo -e ${demo_ps1}
}

## main commands

sub_edit() {
  "${editor:-$EDITOR}" "${prog_home}/PROMPT_STR" 2>/dev/null \
  || die "${err_no_editor}"
}
  
sub_help() {
  [ -z ${s_cmd} ] && main_usage

  man "promptly${s_cmd}" 2>/dev/null \
  || die "${err_no_man}" "${s_cmd}"
}

sub_version() {
  print_version
}
  
sub_show() {
  if [[ -f "${prog_home}/PROMPT_STR" ]]; then
    echo -e "your prompt is set to:"

    while read -r line; do
      echo -e "\t${line}"
    done < "${prog_home}/PROMPT_STR"

    echo -e "\nwhich will display as: \
      \n\t$(evaluate ${prog_home}/PROMPT_STR)\n"
    
  else
    die "" ""
  fi
}

## parse arguments and begin

[[ ${#} -eq 0 ]] && main_usage

main() {
  while [ -n "${1}" ]; do
    case "${1}" in
      --) shift; break;;
      -*) case "${1}" in
      -v|--version)   print_version ;;
      -e|--editor)    if [ ! -z "${2}" ]; then editor="${2}" ; else die "${err_no_argument}" "${1}"; fi; shift ;;
      -h|--help)      if ! is_m_cmd_set;  then main_usage    ; else m_cmd_usage; fi ;;
      -*)             die "${err_invalid_opt}" "${1}" ;;
    esac ;;

    *) if   ! is_m_cmd_set  && is_m_cmd "${1}"; then m_cmd=$(set_m_cmd "${1}")
       elif ! is_m_cmd_set; then die    "${err_invalid_m_cmd}" "${1}"
       elif ! is_s_cmd_set  && is_s_cmd "${1}"; then s_cmd=$(set_s_cmd "${1}")
       elif ! is_s_cmd_set; then die    "${err_invalid_s_cmd}" "${1}"
 
       else   die "${err_invalid_opt}" "${1}"; fi ;;

    esac
    shift

  done

  if ! is_m_cmd_set; then main_usage; fi

  sub_"${m_cmd}"
}

main "${@}"

exit ${prog_exit}

